{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseWallet = void 0;\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../hash/index.js\");\nconst index_js_3 = require(\"../providers/index.js\");\nconst index_js_4 = require(\"../transaction/index.js\");\nconst index_js_5 = require(\"../utils/index.js\");\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nclass BaseWallet extends index_js_3.AbstractSigner {\n  /**\n   *  The wallet address.\n   */\n  address;\n  #signingKey;\n  /**\n   *  Creates a new BaseWallet for %%privateKey%%, optionally\n   *  connected to %%provider%%.\n   *\n   *  If %%provider%% is not specified, only offline methods can\n   *  be used.\n   */\n  constructor(privateKey, provider) {\n    super(provider);\n    (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n    this.#signingKey = privateKey;\n    const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);\n    (0, index_js_5.defineProperties)(this, {\n      address\n    });\n  }\n  // Store private values behind getters to reduce visibility\n  // in console.log\n  /**\n   *  The [[SigningKey]] used for signing payloads.\n   */\n  get signingKey() {\n    return this.#signingKey;\n  }\n  /**\n   *  The private key for this wallet.\n   */\n  get privateKey() {\n    return this.signingKey.privateKey;\n  }\n  async getAddress() {\n    return this.address;\n  }\n  connect(provider) {\n    return new BaseWallet(this.#signingKey, provider);\n  }\n  async signTransaction(tx) {\n    tx = (0, index_js_3.copyRequest)(tx);\n    // Replace any Addressable or ENS name with an address\n    const {\n      to,\n      from\n    } = await (0, index_js_5.resolveProperties)({\n      to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined,\n      from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined\n    });\n    if (to != null) {\n      tx.to = to;\n    }\n    if (from != null) {\n      tx.from = from;\n    }\n    if (tx.from != null) {\n      (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n      delete tx.from;\n    }\n    // Build the transaction\n    const btx = index_js_4.Transaction.from(tx);\n    btx.signature = this.signingKey.sign(btx.unsignedHash);\n    return btx.serialized;\n  }\n  async signMessage(message) {\n    return this.signMessageSync(message);\n  }\n  // @TODO: Add a secialized signTx and signTyped sync that enforces\n  // all parameters are known?\n  /**\n   *  Returns the signature for %%message%% signed with this wallet.\n   */\n  signMessageSync(message) {\n    return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;\n  }\n  async signTypedData(domain, types, value) {\n    // Populate any ENS names\n    const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async name => {\n      // @TODO: this should use resolveName; addresses don't\n      //        need a provider\n      (0, index_js_5.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"resolveName\",\n        info: {\n          name\n        }\n      });\n      const address = await this.provider.resolveName(name);\n      (0, index_js_5.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n        value: name\n      });\n      return address;\n    });\n    return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n  }\n}\nexports.BaseWallet = BaseWallet;","map":{"version":3,"mappings":"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","names":["BaseWallet","index_js_3","address","constructor","privateKey","provider","sign","signingKey","publicKey","getAddress","connect","signTransaction","tx","to","from","undefined","btx","index_js_4","signature","unsignedHash","serialized","signMessage","message","signMessageSync","signTypedData","domain","types","value","populated","index_js_2","resolveNames","name","operation","info","resolveName","hash","exports"],"sources":["/Users/donny/Desktop/FlappyNounsClient/node_modules/ethers/src.ts/wallet/base-wallet.ts"],"sourcesContent":["import { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport {\n    defineProperties, resolveProperties, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport type { SigningKey } from \"../crypto/index.js\";\nimport type { TypedDataDomain, TypedDataField } from \"../hash/index.js\";\nimport type { Provider, TransactionRequest } from \"../providers/index.js\";\nimport type { TransactionLike } from \"../transaction/index.js\";\n\n\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nexport class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey: SigningKey, provider?: null | Provider) {\n        super(provider);\n\n        assertArgument(privateKey && typeof(privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n\n        this.#signingKey = privateKey;\n\n        const address = computeAddress(this.signingKey.publicKey);\n        defineProperties<BaseWallet>(this, { address });\n    }\n\n    // Store private values behind getters to reduce visibility\n    // in console.log\n\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey(): SigningKey { return this.#signingKey; }\n\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey(): string { return this.signingKey.privateKey; }\n\n    async getAddress(): Promise<string> { return this.address; }\n\n    connect(provider: null | Provider): BaseWallet {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n\n    async signTransaction(tx: TransactionRequest): Promise<string> {\n        tx = copyRequest(tx);\n\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await resolveProperties({\n            to: (tx.to ? resolveAddress(tx.to, this.provider): undefined),\n            from: (tx.from ? resolveAddress(tx.from, this.provider): undefined)\n        });\n\n        if (to != null) { tx.to = to; }\n        if (from != null) { tx.from = from; }\n\n        if (tx.from != null) {\n            assertArgument(getAddress(<string>(tx.from)) === this.address,\n                \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n\n        // Build the transaction\n        const btx = Transaction.from(<TransactionLike<string>>tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n\n        return btx.serialized;\n    }\n\n    async signMessage(message: string | Uint8Array): Promise<string> {\n        return this.signMessageSync(message);\n    }\n\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message: string | Uint8Array): string {\n        return this.signingKey.sign(hashMessage(message)).serialized;\n    }\n\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n\n        // Populate any ENS names\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name: string) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n\n            assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n\n            const address = await this.provider.resolveName(name);\n            assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n\n            return address;\n        });\n\n        return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}